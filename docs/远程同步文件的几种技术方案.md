## 背景介绍

最近在做的项目中，有一个场景是需要同步业务代码到本机或远程服务器的另一个目录，文件目录结构是这样的：

```
/node_modules/
/pages/
package.json
README.md
```

下文简称 源目录为 **src**，目标目录为 **target**

## 特点

这种场景的特点是：

+   文件数量多（如 `/node_modules/`）
+   基本无大文件（大于等于 5M）
+   `/node_modules/` 中可能存在没有反映在 `package.json` 中的包
+   `/node_modules/` 中可能存在被修改过的包，比如调试时加的 log 信息

## 几种同步方案

+   【方案一】清空 target，全量复制（本地）/传送（远程）
    +   步骤
        1. 清空 target
        2. 复制 src 到 target 

    +   优点
        +   代码可维护性

            实现简单
            
            后期可维护性强
        
    +   缺点
        +   耗时较长
        +   可能引起 `fd` 资源用尽导致 `file table overflow` 这样的报错

        打开一个文件会消耗一个 `fd` 资源，而系统中 `fd` 数量是有限的，比如 `mac` 默认的上限是 4096
        
+   【方案二】不清空 target，利用 md5 区分文件是否变化
    +   步骤
        +   同步 `package.json`
        
            将 src 的 `package.json` 复制到 target
        
        +   双方执行 `npm install`
        
            src 和 target 执行 `npm install`（在 target 准备一份 `node_modules`，目的是 1. 减少要传送的文件数量；2. 方便文件对比）
            
        +   对比双方文件列表异同
            
            对比 src 和 target 的文件列表（文件的相对路径作为项），将结果分为 **added**、**removed**、**common** 三部分
            
            +   **added**、**removed** 是需要直接传送给 target 的，存储到**待同步目录**
            +   对 **common** 部分的文件，逐个读取相应的文件内容，并根据文件内容生成 MD5 字符串，如果源目录和目标目录中，相同路径的两个文件内容 MD5 不同，则认为修改过，存储到**待同步目录**

                当然读取文件内容以及生成 md5 字符这部分的工作已经有现成的工具了（`md5-file`），一行代码搞定
        
        +   同步文件
            
            将**待同步目录**的所有文件，复制（本地）或上传（远程）到 target 即可

    +   优点
        +   代码可维护性

            实现简单
            
            后期可维护性高
            
        +   性能高

            在第三步读取文件内容部分也会占用 `fd` 资源，通过**同步读取**并且读取后**关闭** `fd` 资源的方式，能够避免 `fd` 资源被用尽的情况
            
        +   待同步文件数量少

            因为 target 目录也执行了 `npm install`，占据文件数量大头的 `node_modules` 目录可以不用完全从 src 传输过去

+   【方案三】rsync
    +   步骤
        +   建立 rsync websocket 通信管道（远程，本地则跳过）
        +   读取 src 文件内容，读取 target 文件内容，进行文件内容校验，以字符为粒度获取不同的部分
        +   以字符为粒度进行文件同步

    +   优点
        +   以字符为粒度进行同步，省流量（特别是大文件）
    +   缺点
        +   代码可维护性

            由于 node 中并没有实现 rsync，文件内容对比、删选字符串等内部算法、逻辑都需要自己实现，代码比较复杂，除了作者，其他人较难维护相同的代码
            
        +   必要性

            考虑到复杂的实现过程，在这种没有大文件的场景中，rsync 的方案并无必要
            
## 结论
    
在当前场景下，从 **代码可维护性**、**实现难易程度**、**性能** 等方面综合考虑，方案二为目前最优解。