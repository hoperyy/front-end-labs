# 匹配一个字符的

+ 普通字符
    +   含义：字母、数字、汉字、下划线、没有特殊定义的标点符号
    +   举例：表达式 `c` 匹配字符 `"c"`
+ 简单的转义字符
    + 不便书写的字符，需要加上 `\`：
        +   `\r` 和 `\n`：回车 和 换行符
        +   `\t`：制表符
    + 字符本身有其他含义，需要加上 `\`：
        +   `\^`：匹配 `^` 符号本身
        +   `\$`：匹配 `$` 符号本身
        +   `\.`：匹配 `.` 符号本身

+ 多个选择符中的一个（**注意：是多个可选字符中的一个，而不是多个**）
    + 系统定义的
        +   `\d`：任意一个数字，`0~9` 中的任意一个字符
        +   `\w`：任意一个字母、数字、下划线，即 `A~Z、a~z、0~9、_` 中的任意一个字符
        +   `\s`：`空格`、`制表符`、`换页符`等 `空白字符` 的其中一个
        +   `.`：小数点可以匹配除了换行符（`\n`）以外的任意一个字符
        +   `/S`：匹配所有非空白字符（`/s` 可匹配各个空白字符）
        +   `/D`:：匹配所有的非数字字符
        +   `/W`：匹配所有的字母、数字、下划线以外的字符
        +   `/B`：匹配非单词边界，即左右两边都是 `/w` 范围或者左右两边都不是 `/w` 范围时的字符缝隙
    + 自定义
        +  `[]`： 匹配 `[]` 中的任意一个字符
        +  `[^]`：匹配括号内字符外的任意一个字符
        
# 匹配多个字符的（次数修饰）

以上内容是匹配一个字符的情况，当需要匹配多个字符时，我们有两种方式：

+   多写几次，如 `/cc/` 匹配字符串 `"cc"`
+   使用“次数修饰”，即可写成 `/c{2}/` 匹配字符串 `"cc"`

次数修饰：

+   位置：
    +   “次数修饰” 放在 “被修饰的表达式” 后面，比如 `/[bcd][bcd]/` 可以写成 `[bcd]{2}`

+   写法
    +   `{n}`：表达式重复 `n` 次。
        +   比如：`\w{2}` 相当于`\w\w`
    +   `{m,n}`：表达式至少重复 `m`，最多重复 `n`
        +   比如：`ba{1,3}` 可以匹配 `ba`、`baa`、`baaa`
    +   `{m,}`：表达式至少重复 `m` 次
        +   比如：`\w\d{2,}` 可以匹配 `a12`、`_456`、`M12345`
    +   `?`：匹配表达式 `0` 次或 `1` 次，相当于 `{0,1}`
        +   比如：`a[cd]?`可以匹配 `a`、`ac`、`ad`
    +   `+`：表达式至少出现 `1` 次，相当于 `{1,}`
        +   比如：`a+b` 可以匹配 `ab`、`aab`、`aaab`……
    +   `*`：表达式不出现或出现任意次，相当于 `{0,}`


# 匹配次数中的贪婪与非贪婪

+   贪婪
    +   解释：
        +   使用修饰匹配次数的特殊符号时，有几种表示方法可以使用同一个表达式能够匹配不同的次数，如 `{m,n}`、`{m,}`、`*`、`+`，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。

    +   举例： 针对 `"dxxxdxxxd"`

        +   表达式 `(d)(\w+)`
            +   `\w+` 将匹配第一个 `"d"` 之后的所有字符 `"xxxdxxxd"`
        +   表达式 `(d)(\w+)(d)`
            +   `\w+` 将匹配第一个 `"d"` 和最后一个 `"d"` 之间的所有字符 `"xxxdxxx"`。虽然 `\w+` 也能够匹配上最后一个 `"d"`，但是为了整个表达式能够匹配成功， `\w+` 可以“让出”它本来能够匹配的最后一个 `"d"`

    +   结论：
        +   由此可见，`/w+` 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 `"d"`，但那也是为了让整个表达式能够匹配成功。同理，带 `*` 和 `{m,n}` 的表达式都是尽可能地多匹配，带 `?` 的表达式在可匹配可不匹配的时候，也是尽可能的 "要匹配"。这 种匹配原则就叫作 "贪婪" 模式 。



+ 非贪婪(勉强)

    + 解释：
        + 在修饰匹配次数的特殊符号后再加上一个 `?` 号，可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的“不匹配”。这种模式叫“非贪婪”模式，又叫“勉强”模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。

    +   举例：针对文本 `"dxxxdxxxd"`

        +   表达式 `(d)(\w+?)`
            +    `\w+?` 将尽可能少地匹配第一个 `"d"` 之后的字符，结果就是 `\w+?` 只匹配了一个 `"x"`
        +   表达式 `(d)(\w+?)(d)`
            +   为了整个表达式匹配成功，`\w+?` 不得不匹配 `xxx` 才可以让后面的 `"d"` 匹配，从而使整个表达式匹配成功。因此结果是 `\w+?` 匹配 `"xxx"`

# 不匹配字符的

+   `^`：不匹配任何字符，与字符串开始的地方匹配
+   `$`：不匹配任何字符，与字符串结束的地方匹配
+   `\b`：匹配一个单词边界，这个边界一边是 `\w`，一边是 `非\w`

# 其他通用规则

+   表达式中，可以使用 `\xNN` 和 `\uNNNN` 表示一个字符（`N`表示一个十六进制数）

+   在表达式 `\s`、`\d`、`\w`、`\b` 表示特殊意义的同时，对应的大写字母表示相反的意义

# 特殊表达式
+   `|`： `或`，匹配左边或右边
    +   tip：如果左右都匹配上了，则只记住左边
+   `()`：有两个作用
    +   tip：在修饰匹配次数的时候，括号内的表达式作为整体被修饰
    +   tip：取匹配结果的时候，括号内的表达式匹配到的结果可以被单独得到
+   `(?:xxx)`：但是如果希望匹配结果不记录供以后使用，可以使用 `(?:xxx)` 的格式
    +    举例：表达式 `"(?:(/w)/1)+"` 匹配 `"a bbccdd efg"` 时，结果是 `"bbccdd"`。括号 `"(?:)"` 范围的匹配结果不进行记录，因此 `"(/w)"` 使用 `"/1"` 来引用。
+ `x(?=y)`：匹配 `x`，仅当后面紧跟 `y` 时。如果符合匹配，则只有 `x` 被记住，`y` 不会被记住
+ `x(?!y)`：匹配 `x`，仅当后面不紧跟 `y` 时。如果符合匹配，则只有 `x` 被记住，`y` 不会被记住
+ 反向引用 `\1`、`\2`……

# 参数

+   `g`
    +   含义：全局匹配

+   `i`
    +   含义：不区分大小写

+   `m`
    +   含义：多行匹配
    +   tip：如果是多行字符，加上此参数后，每行字符串会增加 `^` 和 `$`。


# 方法
+   表达式对象的方法
    +    `exec(str)`
        +   返回值：与表达式匹配的一个字符串，并以数组的形式呈现；如果表达式中含有捕捉用的小括号，则返回的数组中也可能含有 `()` 中匹配的符号
        +   加参数 `g` 的话，如果有多个匹配，则第一次执行 `exec` 返回第一个匹配，继续执行 `exec`，则依次返回第二个、第三个匹配
        +   不加参数 `g` 的话，无论执行多少次 `exec`，都只返回第一个匹配

    +    `test(str)`
        +   作用：判断字符串 `str` 是否匹配表达式，返回一个布尔值
        +   无论是否加参数 `g`，返回结果是一样的
        
+   `String` 的方法
    + `match(expr)`

        +   返回值：返回与 `expr` 相匹配的一个字符串数组
        +   如果没有参数 `g`，则总是返回第一个匹配，加入参数 `g` 则一次性返回所有的匹配

    + `search(expr)`

        +   返回值：返回字符串中与 `expr` 相匹配的第一个匹配的 `index` 值
        +   是否加参数 `g`：效果是一样的

    + `replace(expr, str)`

        +   作用：将字符串中匹配 `expr` 的部分替换为 `str`。。另外在`replace` 方法中，`str` 中可以含有一种变量符号 `$` ，格式为`$n`，代表匹配中被记住的第 `n` 的匹配字符串（注意小括号可以记忆匹配）。

        +   加`g`：全局替换
        +   不加 `g`：只替换第一个匹配

    + `split(expr)`

        +   作用：将字符串以匹配 `expr` 的部分做分割
        +   返回值：返回一个数组
        +   是否加参数 `g`：结果是一样的

# 属性
+   表达式自身的属性
    +   `lastIndex`
        +   返回值：当前匹配字符串的下一个字符的位置
    +   举例：
        +   
                var regx=/u\d/g;
                var rs=regx.exec('u1du2e');
                var lastIndex1=regx.lastIndex;
                rs=regx.exec('u1du2e');
                var lastIndex2=regx.lastIndex;
                rs=regx.exec('u1du2e');
                var lastIndex3=regx.lastIndex; 
                console.log(lastIndex1, lastIndex2, lastIndex3);// 2,5,0
    +    `source`
        +   返回值：返回表达式字符串自身
        +   举例：
                
                var regx=/user\d/;
                var rs=regx.exec('sdsfuser1dfsfuser2');
                var source=regx.source; 

                source的值为user\d
    
+   表达式匹配结果的属性
    +   `index`：返回当前匹配的位置

        +   加入 `g` 有影响

    +   `input` 用于匹配的字符串

    +   `[0]`

        +   返回值：返回匹配结果中的第一个匹配值，对于 `match` 而言可能返回一个多值的数字，除了 `[0]` 之外，还有 `[1]、[2]、[3]……`

        +   注意：
        
                var regx=/user/d/;
                var rs=regx.exec(“sdsfuser1dfsfuser2”);
                var value1=rs[0];
                rs=regx.exec(“sdsfuser1dfsfuser2”);
                var value2=rs[0]; 
                value1的值为user1,value2的值为user2

# tips

+   在 `HTML` 的 `textarea` 输入域中，按一个 `Enter` 键，对应的控制字符为 `/r/n`，即“回车换行”，而不是 `/n/r`